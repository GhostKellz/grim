//! Plugin Build API
//! Provides helper functions for building Grim plugins
//! Makes it easy for plugin authors to create build.zig files

const std = @import("std");
const Build = std.Build;

/// Plugin type
pub const PluginType = enum {
    /// Ghostlang script plugin (.gza)
    ghostlang,

    /// Native Zig shared library (.so/.dylib/.dll)
    native,

    /// Hybrid: Both Ghostlang and native components
    hybrid,
};

/// Plugin configuration
pub const PluginConfig = struct {
    /// Plugin name
    name: []const u8,

    /// Plugin version
    version: []const u8,

    /// Plugin description
    description: []const u8,

    /// Plugin author
    author: []const u8,

    /// Plugin type
    type: PluginType,

    /// Minimum Grim version required
    min_grim_version: []const u8 = "0.1.0",

    /// Root source file for native plugins
    root_source_file: ?[]const u8 = null,

    /// Additional dependencies
    dependencies: []const []const u8 = &.{},

    /// Target platforms (null = all)
    targets: ?[]const std.Build.ResolvedTarget = null,

    /// Optimize mode
    optimize: std.builtin.OptimizeMode = .ReleaseSafe,
};

/// Build a Grim plugin
pub fn buildPlugin(b: *Build, config: PluginConfig) !void {
    const target = b.standardTargetOptions(.{});
    const optimize = b.standardOptimizeOption(.{ .preferred_optimize_mode = config.optimize });

    switch (config.type) {
        .ghostlang => try buildGhostlangPlugin(b, config),
        .native => try buildNativePlugin(b, config, target, optimize),
        .hybrid => {
            try buildGhostlangPlugin(b, config);
            try buildNativePlugin(b, config, target, optimize);
        },
    }

    // Generate plugin manifest
    try generateManifest(b, config);
}

/// Build a Ghostlang plugin
fn buildGhostlangPlugin(b: *Build, config: PluginConfig) !void {
    // Create install step for .gza files
    const install_dir = b.fmt("plugins/{s}", .{config.name});

    // Find all .gza files
    const install_step = b.addInstallDirectory(.{
        .source_dir = b.path("."),
        .install_dir = .prefix,
        .install_subdir = install_dir,
        .include_extensions = &.{".gza"},
    });

    b.getInstallStep().dependOn(&install_step.step);
}

/// Build a native Zig plugin
fn buildNativePlugin(
    b: *Build,
    config: PluginConfig,
    target: std.Build.ResolvedTarget,
    optimize: std.builtin.OptimizeMode,
) !void {
    const lib = b.addSharedLibrary(.{
        .name = config.name,
        .root_source_file = if (config.root_source_file) |f|
            b.path(f)
        else
            b.path("src/main.zig"),
        .target = target,
        .optimize = optimize,
    });

    // Link libc (required for FFI)
    lib.linkLibC();

    // Add Grim core dependency
    // Note: Plugin authors need to add Grim as a dependency in build.zig.zon
    const grim_dep = b.dependency("grim", .{
        .target = target,
        .optimize = optimize,
    });

    lib.root_module.addImport("grim", grim_dep.module("core"));

    // Install the library
    b.installArtifact(lib);

    // Add run tests step
    const tests = b.addTest(.{
        .root_source_file = if (config.root_source_file) |f|
            b.path(f)
        else
            b.path("src/main.zig"),
        .target = target,
        .optimize = optimize,
    });

    tests.root_module.addImport("grim", grim_dep.module("core"));

    const run_tests = b.addRunArtifact(tests);
    const test_step = b.step("test", "Run plugin tests");
    test_step.dependOn(&run_tests.step);
}

/// Generate plugin.zon manifest
fn generateManifest(b: *Build, config: PluginConfig) !void {
    const manifest_content = b.fmt(
        \\// {s} Plugin Manifest
        \\// Auto-generated by Grim Plugin Build API
        \\
        \\.{{
        \\    .name = "{s}",
        \\    .version = "{s}",
        \\    .description = "{s}",
        \\    .author = "{s}",
        \\    .type = "{s}",
        \\    .min_grim_version = "{s}",
        \\}}
        \\
    , .{
        config.name,
        config.name,
        config.version,
        config.description,
        config.author,
        @tagName(config.type),
        config.min_grim_version,
    });

    const write_manifest = b.addWriteFiles();
    _ = write_manifest.add("plugin.zon", manifest_content);

    b.getInstallStep().dependOn(&write_manifest.step);
}

/// Create a basic plugin build.zig template
pub fn createPluginBuildZig(
    allocator: std.mem.Allocator,
    name: []const u8,
    plugin_type: PluginType,
) ![]const u8 {
    const type_str = @tagName(plugin_type);

    const template = try std.fmt.allocPrint(allocator,
        \\const std = @import("std");
        \\const plugin_build = @import("plugin_build.zig");
        \\
        \\pub fn build(b: *std.Build) void {{
        \\    const config = plugin_build.PluginConfig{{
        \\        .name = "{s}",
        \\        .version = "0.1.0",
        \\        .description = "A Grim plugin",
        \\        .author = "Your Name",
        \\        .type = .{s},
        \\    }};
        \\
        \\    plugin_build.buildPlugin(b, config) catch |err| {{
        \\        std.debug.print("Plugin build failed: {{}}\n", .{{err}});
        \\        std.process.exit(1);
        \\    }};
        \\}}
        \\
    , .{ name, type_str });

    return template;
}

/// Create build.zig.zon template
pub fn createPluginBuildZon(
    allocator: std.mem.Allocator,
    name: []const u8,
) ![]const u8 {
    const template = try std.fmt.allocPrint(allocator,
        \\.{{
        \\    .name = "{s}",
        \\    .version = "0.1.0",
        \\    .minimum_zig_version = "0.16.0",
        \\
        \\    .dependencies = .{{
        \\        .grim = .{{
        \\            .path = "../..",
        \\        }},
        \\    }},
        \\
        \\    .paths = .{{
        \\        "build.zig",
        \\        "build.zig.zon",
        \\        "src",
        \\    }},
        \\}}
        \\
    , .{name});

    return template;
}

/// Example native plugin template
pub const NATIVE_PLUGIN_TEMPLATE =
    \\const std = @import("std");
    \\const grim = @import("grim");
    \\
    \\const PluginMetadata = grim.plugin_ffi.PluginMetadata;
    \\const PluginVTable = grim.plugin_ffi.PluginVTable;
    \\const PluginContext = grim.plugin_ffi.PluginContext;
    \\const ABI_VERSION = grim.plugin_ffi.ABI_VERSION;
    \\
    \\// Plugin metadata
    \\const metadata = PluginMetadata{
    \\    .abi_version = ABI_VERSION,
    \\    .name = "example-plugin",
    \\    .version = "0.1.0",
    \\    .description = "An example Grim plugin",
    \\    .author = "Your Name",
    \\    .min_grim_version = "0.1.0",
    \\};
    \\
    \\// Plugin vtable
    \\const vtable = PluginVTable{
    \\    .on_load = onLoad,
    \\    .on_init = onInit,
    \\    .on_deinit = onDeinit,
    \\    .on_reload = null,
    \\};
    \\
    \\// Export plugin metadata
    \\export fn grim_plugin_metadata() callconv(.C) *const PluginMetadata {
    \\    return &metadata;
    \\}
    \\
    \\// Export plugin vtable
    \\export fn grim_plugin_vtable() callconv(.C) *const PluginVTable {
    \\    return &vtable;
    \\}
    \\
    \\// Plugin lifecycle hooks
    \\fn onLoad(ctx: *PluginContext) callconv(.C) c_int {
    \\    const api = ctx.api;
    \\    api.log(.info, "Plugin loaded!");
    \\    return 0;
    \\}
    \\
    \\fn onInit(ctx: *PluginContext) callconv(.C) c_int {
    \\    const api = ctx.api;
    \\    api.log(.info, "Plugin initialized!");
    \\
    \\    // Register a command
    \\    _ = api.register_command("example", exampleCommand);
    \\
    \\    return 0;
    \\}
    \\
    \\fn onDeinit(ctx: *PluginContext) callconv(.C) void {
    \\    const api = ctx.api;
    \\    api.log(.info, "Plugin deinitialized!");
    \\}
    \\
    \\fn exampleCommand(ctx: *PluginContext, args: [*:0]const u8) callconv(.C) c_int {
    \\    _ = ctx;
    \\    const api = ctx.api;
    \\    api.log(.info, "Example command executed!");
    \\    api.log(.info, args);
    \\    return 0;
    \\}
    \\
;

/// Example Ghostlang plugin template
pub const GHOSTLANG_PLUGIN_TEMPLATE =
    \\-- Example Ghostlang Plugin for Grim
    \\-- This is a simple plugin that adds custom commands
    \\
    \\local plugin = {}
    \\
    \\-- Plugin metadata
    \\plugin.name = "example-ghostlang"
    \\plugin.version = "0.1.0"
    \\plugin.description = "An example Ghostlang plugin"
    \\plugin.author = "Your Name"
    \\
    \\-- Called when plugin is loaded
    \\function plugin.on_load()
    \\    print("Ghostlang plugin loaded!")
    \\end
    \\
    \\-- Called when plugin is initialized
    \\function plugin.on_init()
    \\    print("Ghostlang plugin initialized!")
    \\
    \\    -- Register a command
    \\    grim.register_command("hello", plugin.hello_command)
    \\end
    \\
    \\-- Example command
    \\function plugin.hello_command(args)
    \\    print("Hello from Ghostlang plugin!")
    \\    print("Args: " .. args)
    \\end
    \\
    \\-- Called when plugin is unloaded
    \\function plugin.on_deinit()
    \\    print("Ghostlang plugin deinitialized!")
    \\end
    \\
    \\return plugin
    \\
;
