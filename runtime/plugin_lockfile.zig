//! Plugin lockfile system for verifying plugin integrity
//! Generates and validates SHA-256 hashes of plugin files

const std = @import("std");
const crypto = std.crypto;

/// Plugin lockfile entry
pub const LockEntry = struct {
    name: []const u8,
    version: []const u8,
    sha256: [32]u8, // SHA-256 hash (256 bits = 32 bytes)
    path: []const u8,
    timestamp: i64, // Unix timestamp when locked

    pub fn format(
        self: LockEntry,
        comptime fmt: []const u8,
        options: std.fmt.FormatOptions,
        writer: anytype,
    ) !void {
        _ = fmt;
        _ = options;
        const hash_hex = std.fmt.bytesToHex(self.sha256, .lower);
        try writer.print("{s}@{s} (sha256:{s})", .{ self.name, self.version, hash_hex });
    }
};

/// Plugin lockfile manager
pub const PluginLockfile = struct {
    allocator: std.mem.Allocator,
    entries: std.StringHashMap(LockEntry),
    lockfile_path: []const u8,

    pub fn init(allocator: std.mem.Allocator, lockfile_path: []const u8) !*PluginLockfile {
        const self = try allocator.create(PluginLockfile);
        self.* = .{
            .allocator = allocator,
            .entries = std.StringHashMap(LockEntry).init(allocator),
            .lockfile_path = try allocator.dupe(u8, lockfile_path),
        };
        return self;
    }

    pub fn deinit(self: *PluginLockfile) void {
        var it = self.entries.iterator();
        while (it.next()) |entry| {
            self.allocator.free(entry.key_ptr.*);
            self.allocator.free(entry.value_ptr.name);
            self.allocator.free(entry.value_ptr.version);
            self.allocator.free(entry.value_ptr.path);
        }
        self.entries.deinit();
        self.allocator.free(self.lockfile_path);
        self.allocator.destroy(self);
    }

    /// Load lockfile from disk
    pub fn load(self: *PluginLockfile) !void {
        const content = std.fs.cwd().readFileAlloc(self.lockfile_path, self.allocator, @enumFromInt(10 * 1024 * 1024)) catch |err| switch (err) {
            error.FileNotFound => return, // Lockfile doesn't exist yet, that's OK
            else => return err,
        };
        defer self.allocator.free(content);

        try self.parseContent(content);
    }

    /// Save lockfile to disk
    pub fn save(self: *PluginLockfile) !void {
        const file = try std.fs.cwd().createFile(self.lockfile_path, .{ .truncate = true });
        defer file.close();

        // Write header
        try file.writeAll("# Grim Plugin Lockfile\n");
        try file.writeAll("# DO NOT EDIT MANUALLY\n");
        try file.writeAll("# Generated by grim plugin manager\n\n");

        // Write entries
        var it = self.entries.iterator();
        while (it.next()) |entry| {
            const lock = entry.value_ptr.*;

            // Convert hash to hex string using stdlib
            const hash_hex = std.fmt.bytesToHex(lock.sha256, .lower);

            var line_buf: [1024]u8 = undefined;
            const line1 = try std.fmt.bufPrint(&line_buf, "[plugin.{s}]\n", .{lock.name});
            try file.writeAll(line1);

            const line2 = try std.fmt.bufPrint(&line_buf, "version = \"{s}\"\n", .{lock.version});
            try file.writeAll(line2);

            const line3 = try std.fmt.bufPrint(&line_buf, "sha256 = \"{s}\"\n", .{hash_hex});
            try file.writeAll(line3);

            const line4 = try std.fmt.bufPrint(&line_buf, "path = \"{s}\"\n", .{lock.path});
            try file.writeAll(line4);

            const line5 = try std.fmt.bufPrint(&line_buf, "timestamp = {d}\n\n", .{lock.timestamp});
            try file.writeAll(line5);
        }
    }

    /// Add or update a plugin entry
    pub fn addPlugin(self: *PluginLockfile, name: []const u8, version: []const u8, path: []const u8) !void {
        // Calculate SHA-256 hash of the plugin file
        const hash = try self.calculateFileHash(path);

        const entry = LockEntry{
            .name = try self.allocator.dupe(u8, name),
            .version = try self.allocator.dupe(u8, version),
            .sha256 = hash,
            .path = try self.allocator.dupe(u8, path),
            .timestamp = std.time.timestamp(),
        };

        const key = try self.allocator.dupe(u8, name);
        try self.entries.put(key, entry);
    }

    /// Verify a plugin against its lockfile entry
    pub fn verify(self: *PluginLockfile, name: []const u8, path: []const u8) !bool {
        const entry = self.entries.get(name) orelse return error.PluginNotLocked;

        // Calculate current hash
        const current_hash = try self.calculateFileHash(path);

        // Compare hashes
        return std.mem.eql(u8, &entry.sha256, &current_hash);
    }

    /// Calculate SHA-256 hash of a file
    fn calculateFileHash(self: *PluginLockfile, path: []const u8) ![32]u8 {
        _ = self;
        const file = try std.fs.cwd().openFile(path, .{});
        defer file.close();

        var hasher = crypto.hash.sha2.Sha256.init(.{});
        var buf: [4096]u8 = undefined;

        while (true) {
            const bytes_read = try file.read(&buf);
            if (bytes_read == 0) break;
            hasher.update(buf[0..bytes_read]);
        }

        var hash: [32]u8 = undefined;
        hasher.final(&hash);
        return hash;
    }

    /// Parse lockfile content (simple TOML-like format)
    fn parseContent(self: *PluginLockfile, content: []const u8) !void {
        var lines = std.mem.splitScalar(u8, content, '\n');
        var current_name: ?[]const u8 = null;
        var current_version: ?[]const u8 = null;
        var current_hash: ?[32]u8 = null;
        var current_path: ?[]const u8 = null;
        var current_timestamp: i64 = 0;

        while (lines.next()) |line| {
            const trimmed = std.mem.trim(u8, line, &std.ascii.whitespace);
            if (trimmed.len == 0 or trimmed[0] == '#') continue;

            if (std.mem.startsWith(u8, trimmed, "[plugin.")) {
                // Save previous entry if exists
                if (current_name) |name| {
                    if (current_version != null and current_hash != null and current_path != null) {
                        try self.entries.put(
                            try self.allocator.dupe(u8, name),
                            LockEntry{
                                .name = try self.allocator.dupe(u8, name),
                                .version = try self.allocator.dupe(u8, current_version.?),
                                .sha256 = current_hash.?,
                                .path = try self.allocator.dupe(u8, current_path.?),
                                .timestamp = current_timestamp,
                            },
                        );
                    }
                }

                // Parse plugin name
                const start = std.mem.indexOf(u8, trimmed, "[plugin.").? + 8;
                const end = std.mem.indexOf(u8, trimmed[start..], "]") orelse continue;
                current_name = trimmed[start .. start + end];
                current_version = null;
                current_hash = null;
                current_path = null;
                current_timestamp = 0;
            } else if (std.mem.indexOf(u8, trimmed, " = ")) |eq_pos| {
                const key = std.mem.trim(u8, trimmed[0..eq_pos], &std.ascii.whitespace);
                const value = std.mem.trim(u8, trimmed[eq_pos + 3 ..], &std.ascii.whitespace);

                if (std.mem.eql(u8, key, "version")) {
                    current_version = std.mem.trim(u8, value, "\"");
                } else if (std.mem.eql(u8, key, "sha256")) {
                    const hash_hex = std.mem.trim(u8, value, "\"");
                    if (hash_hex.len == 64) {
                        var hash: [32]u8 = undefined;
                        _ = try std.fmt.hexToBytes(&hash, hash_hex);
                        current_hash = hash;
                    }
                } else if (std.mem.eql(u8, key, "path")) {
                    current_path = std.mem.trim(u8, value, "\"");
                } else if (std.mem.eql(u8, key, "timestamp")) {
                    current_timestamp = try std.fmt.parseInt(i64, value, 10);
                }
            }
        }

        // Save last entry
        if (current_name) |name| {
            if (current_version != null and current_hash != null and current_path != null) {
                try self.entries.put(
                    try self.allocator.dupe(u8, name),
                    LockEntry{
                        .name = try self.allocator.dupe(u8, name),
                        .version = try self.allocator.dupe(u8, current_version.?),
                        .sha256 = current_hash.?,
                        .path = try self.allocator.dupe(u8, current_path.?),
                        .timestamp = current_timestamp,
                    },
                );
            }
        }
    }

    /// Get entry for a plugin
    pub fn getEntry(self: *PluginLockfile, name: []const u8) ?LockEntry {
        return self.entries.get(name);
    }

    /// Remove a plugin entry
    pub fn removePlugin(self: *PluginLockfile, name: []const u8) void {
        if (self.entries.fetchRemove(name)) |kv| {
            self.allocator.free(kv.key);
            self.allocator.free(kv.value.name);
            self.allocator.free(kv.value.version);
            self.allocator.free(kv.value.path);
        }
    }
};

test "lockfile basic operations" {
    const allocator = std.testing.allocator;

    const temp_file = "/tmp/grim-test-lockfile.toml";
    defer std.fs.cwd().deleteFile(temp_file) catch {};

    var lockfile = try PluginLockfile.init(allocator, temp_file);
    defer lockfile.deinit();

    // Create a test plugin file
    const test_plugin_path = "/tmp/test-plugin.gza";
    const test_content = "// Test plugin\nprint('hello');\n";
    try std.fs.cwd().writeFile(.{ .sub_path = test_plugin_path, .data = test_content });
    defer std.fs.cwd().deleteFile(test_plugin_path) catch {};

    // Add plugin
    try lockfile.addPlugin("test-plugin", "1.0.0", test_plugin_path);

    // Save lockfile
    try lockfile.save();

    // Verify plugin
    const is_valid = try lockfile.verify("test-plugin", test_plugin_path);
    try std.testing.expect(is_valid);

    // Load lockfile again
    var lockfile2 = try PluginLockfile.init(allocator, temp_file);
    defer lockfile2.deinit();
    try lockfile2.load();

    // Verify entry exists
    const entry = lockfile2.getEntry("test-plugin");
    try std.testing.expect(entry != null);
    try std.testing.expectEqualStrings("1.0.0", entry.?.version);
}
